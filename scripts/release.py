import argparse
import subprocess
import sys
import logging
import os
import re
import time

from git import Head, Repo
from enum import Enum
from pathlib import Path
from dataclasses import dataclass


logging.basicConfig(level=logging.INFO, format="%(levelname)s: %(message)s")
INFO = logging.info
ERROR = logging.error


SCRIPT_PATH = Path(__file__)
SCRIPT_DIR = SCRIPT_PATH.parent
PROJECT_DIR = SCRIPT_DIR.parent

MAIN_BRANCH = "fake_main"
DEV_BRANCH = "dev"
RELEASE_BRANCH = "release"

RELEASE_NOTES_FILE = PROJECT_DIR.joinpath("metadata/RELEASE_NOTES.md")
VERSION_FILE = PROJECT_DIR.joinpath("metadata/VERSION")
TEST_SCRIPT = PROJECT_DIR.joinpath("scripts/test.sh")

AUTOGENERATED_DISCLAIMER = f"""<!--
This file is automatically generated by {SCRIPT_DIR.name}/{SCRIPT_PATH.name}
Any modifications or changes made directly to this file may be overwritten.
Please use {SCRIPT_DIR.name}/{SCRIPT_PATH.name} instead.
-->"""


class Update(Enum):
    MAJOR = "major"
    MINOR = "minor"
    PATCH = "patch"


@dataclass
class Version:
    major: int
    minor: int
    patch: int

    _file: Path
    _line: int

    def __str__(self):
        return f"{self.major}.{self.minor}.{self.patch}"

    def increment(self, update: Update):
        match update:
            case Update.MAJOR:
                self.major = self.major + 1
            case Update.MINOR:
                self.minor = self.minor + 1
            case Update.PATCH:
                self.patch = self.patch + 1

    def parse_from(file: Path) -> "Version":
        PATTERN = r"([0-9]*)\.([0-9]*)\.([0-9]*)"
        with open(file, "r") as file:
            for index, line in enumerate(file):
                match = re.search(PATTERN, line)
                if match:
                    return Version(
                        int(match.group(1)),
                        int(match.group(2)),
                        int(match.group(3)),
                        Path(file.name),
                        index,
                    )

        return None

    def commit(self):
        with open(self._file, "r") as file:
            lines = file.readlines()

        lines[self._line] = f"{self}\n"

        with open(self._file, "w") as file:
            file.writelines(lines)


def create_if_not_exist(path: Path, content: str):
    if not path.exists():
        with open(path, "w") as file:
            file.write(content)


def run_bash(script: Path) -> bool:
    res = subprocess.run(
        ["bash", script], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True
    )
    print(res.stdout + res.stderr)
    return not bool(res.returncode)


def update_release_notes(file: Path, version: Version) -> bool:
    RELEASE_HEADER = f"\n## Release v{version}\n- "
    with open(file, "a") as f:
        f.write(RELEASE_HEADER)

    last_update = os.path.getmtime(file)
    res = subprocess.run(["code", file], check=False)
    if res.returncode != 0:
        return False

    while True:
        time.sleep(2)
        if last_update != os.path.getmtime(file):
            return True


def abort(message: str, gracefully: bool = False):
    if not gracefully:
        ERROR(f"{message}! Aborting")
        code = 1
    else:
        INFO(f"{message}")
        code = 0

    sys.exit(code)


def main():
    args_parser = argparse.ArgumentParser(description="Project release script")
    args_parser.add_argument(
        "-u", "--update", type=str, choices=[u.value for u in Update], required=True
    )
    args_parser.add_argument(
        "-y",
        "--yes",
        action="store_const",
        const=True,
        help="Bypasses user double-checking",
    )

    update = Update[args_parser.parse_args().update.upper()]
    bypass = args_parser.parse_args().yes

    INFO("Running unit tests")
    if not run_bash(TEST_SCRIPT):
        abort("Tests failed")

    create_if_not_exist(VERSION_FILE, f"{AUTOGENERATED_DISCLAIMER}\n\n0.0.0\n")
    create_if_not_exist(RELEASE_NOTES_FILE, f"{AUTOGENERATED_DISCLAIMER}\n")

    version = Version.parse_from(VERSION_FILE)
    if not version:
        abort("Version file is malformed")

    INFO(f"Current version is v{version}")
    version.increment(update)

    INFO(f"Release version is v{version}, correct? {'y' if bypass else 'yn ->'}")
    if not bypass and not input().lower() == "y":
        abort("Ok. See you later", gracefully=True)

    INFO(f"Updating {VERSION_FILE.name} file")
    version.commit()

    INFO(f"Updating {RELEASE_NOTES_FILE.name} file")
    if not update_release_notes(RELEASE_NOTES_FILE, version):
        abort("Cannot update release notes")

    repo = Repo(PROJECT_DIR)

    dev_branch = repo.branches[DEV_BRANCH]
    dev_branch.commit(f"v{version}")

    main_branch = repo.branches[MAIN_BRANCH]
    main_branch.checkout()
    repo.git.merge("--no-ff", DEV_BRANCH)

    # commit into dev and master
    # make new release branch from master
    # delete all unnecessary folders, change root CMakeLists.txt
    # commit changes into release branch
    # merge release branch into 'release' and put a tag on it
    # delete release branch
    # push new master, dev, release to origin

    INFO(f"Great! New release v{version} is ready. See you later")


if __name__ == "__main__":
    main()
